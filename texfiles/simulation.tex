\section{Simulation in QuantumOptics.jl}

\subsection{Simulation for Longitudinal Pump}

First, we'll add all the packages that we need:

\begin{lstlisting}
using QuantumOptics, PyPlot, Printf, LinearAlgebra
\end{lstlisting}We define the bases, as well as the raising and lowering operators:

\begin{lstlisting}
b_position = PositionBasis(xmin, xmax, Nsteps)
b_fock = FockBasis(N_cutoff)

p = momentum(b_position)

a = destroy(b_fock) ⊗ one(b_position)
ad = dagger(a);
\end{lstlisting}We define the Hamiltonian and calculate the ground and first and second excited states:

\begin{lstlisting}
potential = x -> U0*cos(k*x)^2
H_int = (one(b_fock) ⊗ potentialoperator(b_position, potential))*ad*a
H_kin = (one(b_fock) ⊗ p^2) / k^2
H_pump = η*(a + ad)
H_cavity = -Δc*ad*a
H = H_kin + dense(H_int) + H_pump + H_cavity

E, ψ_states = eigenstates((H + dagger(H))/2, 3);
\end{lstlisting}If we want to plot the wave function, we'll have to extract the position part of the composite basis. We can do that with the command \texttt{ptrace()}:

\begin{lstlisting}
pos_dense = ptrace(ψ_states[1], 1)
density = diag(pos_dense.data)
ada_exp = expect(ad*a, ψ_states[i])
\end{lstlisting} We can also plot the momentum distribution:

\begin{lstlisting}
b_momentum = MomentumBasis(b_position)
Tpx = transform(b_momentum, b_position)

pos_dense = ptrace(ψ_states[1], 1)
states_p = Tpx * pos_dense
density_p = diag(states_p.data)
\end{lstlisting}For the photon number distribution, we trace out the position basis to get only the Fock basis.

\subsection{Simulation for transversal pump}

The bases are the same as before. However, we have to define different Hamiltonians:

\begin{lstlisting}
potential = x -> U0*cos(k*x)^2
H_int = (one(b_fock) ⊗ potentialoperator(b_position, potential))*ad*a
H_kin = (one(b_fock) ⊗ p^2) / k^2
pump = x -> η*cos(k*x)
H_pump = (one(b_fock) ⊗ potentialoperator(b_position, pump)) * (a + ad)
H_cavity = -Δc*ad*a
H = H_kin + dense(H_int) + H_pump + H_cavity

E, states = eigenstates((H + dagger(H))/2, 1);
\end{lstlisting} To visualize the degree of self-organization, we'll use the Husimi Q representation of the ground state. This can be achieved with the command \texttt{qfunc()}:

\begin{lstlisting}
boundary = 3.6
xvec = [-boundary:.1:boundary;]
yvec = [-boundary:.1:boundary;]
grid = qfunc(ptrace(states[1], 2), xvec, yvec)
\end{lstlisting}The variable \texttt{boundary} was set heuristically for plotting.